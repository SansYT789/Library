local Players = game:GetService("Players")
local PathfindingService = game:GetService("PathfindingService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local humanoid = char:WaitForChild("Humanoid")
local root = char:WaitForChild("HumanoidRootPart")

-- Cấu hình
local WALK_RADIUS = 50
local CIRCLE_RADIUS = 20
local STUCK_TIMEOUT = 4
local TELEPORT_DISTANCE = 10
local PLAYER_AVOID_RADIUS = 10 -- né player khác

local lastPos = root.Position
local stuckTime = 0

-- Kiểm tra player đang tự di chuyển
local function playerIsMoving()
	return UserInputService:IsKeyDown(Enum.KeyCode.W)
		or UserInputService:IsKeyDown(Enum.KeyCode.A)
		or UserInputService:IsKeyDown(Enum.KeyCode.S)
		or UserInputService:IsKeyDown(Enum.KeyCode.D)
		or humanoid.Jump
end

-- Lấy danh sách player khác
local function getOtherPlayers()
	local list = {}
	for _, p in ipairs(Players:GetPlayers()) do
		if p ~= player and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
			table.insert(list, p.Character.HumanoidRootPart)
		end
	end
	return list
end

-- Random point vòng tròn + né player khác
local function getRandomPoint()
	local center = workspace.CurrentCamera.CFrame.Position
	local angle = math.random() * math.pi * 2
	local circleOffset = Vector3.new(math.cos(angle),0,math.sin(angle))*CIRCLE_RADIUS
	local randOffset = Vector3.new(math.random(-WALK_RADIUS,WALK_RADIUS),0,math.random(-WALK_RADIUS,WALK_RADIUS))
	local point = center + circleOffset + randOffset

	-- Né player khác
	for _, part in ipairs(getOtherPlayers()) do
		if (part.Position - point).Magnitude < PLAYER_AVOID_RADIUS then
			point = point + Vector3.new(math.random(-PLAYER_AVOID_RADIUS,PLAYER_AVOID_RADIUS),0,math.random(-PLAYER_AVOID_RADIUS,PLAYER_AVOID_RADIUS))
		end
	end
	return point
end

-- Di chuyển smooth theo waypoint
local function moveAlongPath(path)
	for _, waypoint in ipairs(path:GetWaypoints()) do
		local targetPos = waypoint.Position
		if waypoint.Action == Enum.PathWaypointAction.Jump then
			humanoid.Jump = true
		end

		local reached = false
		while not reached do
			if playerIsMoving() then break end
			local dir = (targetPos - root.Position)
			if dir.Magnitude < 2 then
				reached = true
			else
				humanoid:Move(Vector3.new(dir.X,0,dir.Z).Unit)
			end
			RunService.RenderStepped:Wait()
		end
	end
end

-- Tạo path mới
local function createPath(destination)
	local path = PathfindingService:CreatePath({
		AgentRadius = 2,
		AgentHeight = 5,
		AgentCanJump = true,
		AgentJumpHeight = 25,
		AgentMaxSlope = 45
	})
	path:ComputeAsync(root.Position,destination)
	if path.Status == Enum.PathStatus.Complete then
		moveAlongPath(path)
	else
		root.CFrame = CFrame.new(destination + Vector3.new(0,3,0))
	end
end

-- Loop auto move
task.spawn(function()
	while true do
		RunService.RenderStepped:Wait()

		-- Anti-stuck
		if (root.Position - lastPos).Magnitude < 1 then
			stuckTime = stuckTime + RunService.RenderStepped:Wait()
			if stuckTime > STUCK_TIMEOUT then
				root.CFrame = root.CFrame + Vector3.new(TELEPORT_DISTANCE,3,0)
				stuckTime = 0
			end
		else
			stuckTime = 0
		end
		lastPos = root.Position

		-- Nếu player không di chuyển → tạo path mới
		if not playerIsMoving() then
			local point = getRandomPoint()
			createPath(point)
		end
	end
end)
