local Players = game:GetService("Players")
local PathfindingService = game:GetService("PathfindingService")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local humanoid = char:WaitForChild("Humanoid")
local root = char:WaitForChild("HumanoidRootPart")

local STUCK_TIMEOUT = 5
local TELEPORT_DISTANCE = 10
local WALK_RADIUS = 50

local lastPos = root.Position
local stuckTime = 0
local moving = false

-- Random point quanh camera
local function getRandomPoint()
	local base = workspace.CurrentCamera.CFrame.Position
	local offset = Vector3.new(
		math.random(-WALK_RADIUS, WALK_RADIUS),
		0,
		math.random(-WALK_RADIUS, WALK_RADIUS)
	)
	return base + offset
end

-- Đi tới 1 điểm bằng pathfinding
local function moveToPoint(destination)
	local path = PathfindingService:CreatePath()
	path:ComputeAsync(root.Position, destination)

	if path.Status == Enum.PathStatus.Complete then
		local waypoints = path:GetWaypoints()
		moving = true
		for _, waypoint in ipairs(waypoints) do
			humanoid:MoveTo(waypoint.Position)
			local reached = humanoid.MoveToFinished:Wait()
			if not reached then break end
		end
		moving = false
	else
		-- nếu fail thì TP nhẹ
		root.CFrame = CFrame.new(destination + Vector3.new(0, 3, 0))
	end
end

-- Loop chính
task.spawn(function()
	while task.wait(0.2) do
		-- check stuck
		local dist = (root.Position - lastPos).Magnitude
		if dist < 1 then
			stuckTime = stuckTime + 0.2
			if stuckTime >= STUCK_TIMEOUT then
				print("⚠️ Stuck → teleport nhẹ...")
				root.CFrame = root.CFrame + Vector3.new(TELEPORT_DISTANCE, 3, 0)
				stuckTime = 0
				moving = false
			end
		else
			stuckTime = 0
		end
		lastPos = root.Position

		-- nếu không di chuyển thì chọn điểm mới
		if not moving then
			local newPoint = getRandomPoint()
			task.spawn(function()
				moveToPoint(newPoint)
			end)
		end
	end
end)
